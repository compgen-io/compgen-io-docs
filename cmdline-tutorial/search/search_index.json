{"config":{"lang":["en"],"prebuild_index":false,"prebuilt_index":"python","separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the command-line Using a command-line to interact with either your computer or a remote server can be a great way to get things done. A command-line is a powerful tool for working with a computer of any size. In particular, with command-lines, automating data analysis workflows can be performed by chaining together different programs. By chaining programs together, you can create complex workflows with surprisingly simple components. Additionally, many large systems, such as high-performance computing (HPC) clusters, only allow for command-line access, with occasional web-based access for specific tools that require a GUI. Learning to use the command-line can make almost any data analysis task easier. Getting started with the command-line Unix concepts Terminal and Connecting to remote servers Common commands Tranferring data Customizing the shell Writing scripts Data pipelines Other links Version control with git Git Working with an HPC cluster Clusters","title":"Welcome"},{"location":"#markdown","text":"Using a command-line to interact with either your computer or a remote server can be a great way to get things done. A command-line is a powerful tool for working with a computer of any size. In particular, with command-lines, automating data analysis workflows can be performed by chaining together different programs. By chaining programs together, you can create complex workflows with surprisingly simple components. Additionally, many large systems, such as high-performance computing (HPC) clusters, only allow for command-line access, with occasional web-based access for specific tools that require a GUI. Learning to use the command-line can make almost any data analysis task easier.","title":"Welcome"},{"location":"#getting-started-with-the-command-line","text":"Unix concepts Terminal and Connecting to remote servers Common commands Tranferring data Customizing the shell Writing scripts Data pipelines Other links","title":"Getting started with the command-line"},{"location":"#version-control-with-git","text":"Git","title":"Version control with git"},{"location":"#working-with-an-hpc-cluster","text":"Clusters","title":"Working with an HPC cluster"},{"location":"common/","text":"Common commands The command-line consists of a command-prompt and then output from the command. Navigating the file system Listing files in the current directory is performed using the ls command. ls has many options. By default, the sort order of the files is alphabetical, with capital letters first, then lowercase letters (A-Za-z). A few of the more common arguments are listed below. Listing files in the current directory $ ls file1 file2 file3 file4 Listing the long version\u2026 ls -l $ ls -l -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 ( permissions ) ( links ) ( filename ) ( owner ) ( group ) ( Modified date ) ( size in bytes ) Listing all files (including hidden files). Any file that starts with a '.' will be hidden by default. Many programs will write to files that start with a '.' to save configuration or temporary data. All directories contain two directories by default '.' and '..' . '.' is the same as the current directory. So, in the below case file1 and ./file1 point to the exact same file. '..' is the same as the parent directory (up the file hierarchy). '.' and '..' are also considered hidden files. $ ls -la drwxr-xr-x 6 mbreese staff 192 Mar 31 16 :31 . drwxr-xr-x 38 mbreese staff 1216 Mar 31 16 :30 .. -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :33 .hidden_file -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 Here are some other ls options: Arg Meaning -a Show all files -l Long display (permissions, owner, group, size, date) -1 show only one file per line (without the \u2018long\u2019 information) -h human readable file sizes (K, M, G) -t sort by time (newest to oldest) -r reverse the sort (z-aZ-A or oldest to newest) -R recursively display files (display this directory, and all sub-directories) Creating a directory $ mkdir new_directory Changing directories $ cd new_directory Changing to the parent directory (up a level) $ cd .. \u201c .. \u201d is one of those hidden files, but it is present in every directory, and it always means the parent directory Removing a directory $ rmdir bad_directory Danger You can remove only empty directories this way. If the directory has files in it, you need to remove the files first. Alternatively you can use this command to remove both the files and the directory: $ rm -r bad_directory_with_files But be careful \u2013 one wrong finger and you could delete months worth of work. It\u2019s always better to test things out first, before running rm -r . File streams Pipes Miscellaneous commands Change your password $ passwd <Prompt for your current password> <Prompt for your new password> <Repeat new password> Print out the date/time $ date Tue Mar 31 16 :28:20 EDT 2020 Clear the screen $ clear What is your username? (This is more helpful in the context of scripts, but still good to know) $ whoami my_username Writes the phrase \u201cHello World\u201d to the terminal echo \"Hello World\" echo \"a;lksdjfl;aksdjf;lkjsdf\" echo \"world\" pwd ls ls ls -l mkdir new_dir ls -l cd new_dir ls -l ls -las ls -l . ls -la . ls -la .. ls -l .. ls -la cd .. ls -l cd new_dir date echo \"hello\" echo \"hello\" > file.txt cat file.txt echo \" world\" > file2.txt cat file.txt file2.txt cat file.txt file2.txt > file3.txt cat file3.txt cat file2.txt echo \"world\" > file2.txt cat file2.txt cat file.txt file2.txt cat file3.txt md5 echo \"hello\" echo \"hello\" | md5 md5 file.txt echo \"hello\" | md5 echo \"hello1\" | md5 echo \"hello\" | md5 echo \"hell0\" | md5 echo \"hell0\" | base64 ls / ls -l pwd ls ~ ls ~ -l ls -l ~ ls -l ~ | tail -n 5 ls -l ~ | head -n 5 ls -l ~ | less ls -l ~ | less ls ls -l ls -l ls -l | grep file2 ls -l | grep file echo \"my stdout\" | cat cat * grep world file2.txt grep world file3.txt grep grep world * cat * | grep world grep world grep world * mkdir sub_dir echo \"this is another file with the word world in it\" > sub_dir/newfile.txt cat sub_dir/newfile.txt grep world * grep -R world * curl curl --head --silent google.com curl --head --silent google.com | grep Location curl google.com curl -L google.com curl -L google.com | less ssh asclab-c1 curl asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv clear curl -L asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv | less curl -L asclab.ucsf.edu/test.csv | less -S curl -L asclab.ucsf.edu/test.csv | grep MYC curl -L asclab.ucsf.edu/test.csv | grep -w MYC curl -L asclab.ucsf.edu/test.csv | grep -w '^MYC' curl -L --silent asclab.ucsf.edu/test.csv | grep -w '^MYC' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'ABL' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'ABL1' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wI 'ABL1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wI 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wi 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wi 'abl1' | less -S ssh asclab-c1.ucsf.edu","title":"Common"},{"location":"common/#navigating-the-file-system","text":"Listing files in the current directory is performed using the ls command. ls has many options. By default, the sort order of the files is alphabetical, with capital letters first, then lowercase letters (A-Za-z). A few of the more common arguments are listed below. Listing files in the current directory $ ls file1 file2 file3 file4 Listing the long version\u2026 ls -l $ ls -l -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 ( permissions ) ( links ) ( filename ) ( owner ) ( group ) ( Modified date ) ( size in bytes ) Listing all files (including hidden files). Any file that starts with a '.' will be hidden by default. Many programs will write to files that start with a '.' to save configuration or temporary data. All directories contain two directories by default '.' and '..' . '.' is the same as the current directory. So, in the below case file1 and ./file1 point to the exact same file. '..' is the same as the parent directory (up the file hierarchy). '.' and '..' are also considered hidden files. $ ls -la drwxr-xr-x 6 mbreese staff 192 Mar 31 16 :31 . drwxr-xr-x 38 mbreese staff 1216 Mar 31 16 :30 .. -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :33 .hidden_file -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 Here are some other ls options: Arg Meaning -a Show all files -l Long display (permissions, owner, group, size, date) -1 show only one file per line (without the \u2018long\u2019 information) -h human readable file sizes (K, M, G) -t sort by time (newest to oldest) -r reverse the sort (z-aZ-A or oldest to newest) -R recursively display files (display this directory, and all sub-directories) Creating a directory $ mkdir new_directory Changing directories $ cd new_directory Changing to the parent directory (up a level) $ cd .. \u201c .. \u201d is one of those hidden files, but it is present in every directory, and it always means the parent directory Removing a directory $ rmdir bad_directory Danger You can remove only empty directories this way. If the directory has files in it, you need to remove the files first. Alternatively you can use this command to remove both the files and the directory: $ rm -r bad_directory_with_files But be careful \u2013 one wrong finger and you could delete months worth of work. It\u2019s always better to test things out first, before running rm -r .","title":"Navigating the file system"},{"location":"common/#file-streams","text":"","title":"File streams"},{"location":"common/#pipes","text":"","title":"Pipes"},{"location":"common/#miscellaneous-commands","text":"Change your password $ passwd <Prompt for your current password> <Prompt for your new password> <Repeat new password> Print out the date/time $ date Tue Mar 31 16 :28:20 EDT 2020 Clear the screen $ clear What is your username? (This is more helpful in the context of scripts, but still good to know) $ whoami my_username Writes the phrase \u201cHello World\u201d to the terminal echo \"Hello World\" echo \"a;lksdjfl;aksdjf;lkjsdf\" echo \"world\" pwd ls ls ls -l mkdir new_dir ls -l cd new_dir ls -l ls -las ls -l . ls -la . ls -la .. ls -l .. ls -la cd .. ls -l cd new_dir date echo \"hello\" echo \"hello\" > file.txt cat file.txt echo \" world\" > file2.txt cat file.txt file2.txt cat file.txt file2.txt > file3.txt cat file3.txt cat file2.txt echo \"world\" > file2.txt cat file2.txt cat file.txt file2.txt cat file3.txt md5 echo \"hello\" echo \"hello\" | md5 md5 file.txt echo \"hello\" | md5 echo \"hello1\" | md5 echo \"hello\" | md5 echo \"hell0\" | md5 echo \"hell0\" | base64 ls / ls -l pwd ls ~ ls ~ -l ls -l ~ ls -l ~ | tail -n 5 ls -l ~ | head -n 5 ls -l ~ | less ls -l ~ | less ls ls -l ls -l ls -l | grep file2 ls -l | grep file echo \"my stdout\" | cat cat * grep world file2.txt grep world file3.txt grep grep world * cat * | grep world grep world grep world * mkdir sub_dir echo \"this is another file with the word world in it\" > sub_dir/newfile.txt cat sub_dir/newfile.txt grep world * grep -R world * curl curl --head --silent google.com curl --head --silent google.com | grep Location curl google.com curl -L google.com curl -L google.com | less ssh asclab-c1 curl asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv clear curl -L asclab.ucsf.edu/test.csv curl -L asclab.ucsf.edu/test.csv | less curl -L asclab.ucsf.edu/test.csv | less -S curl -L asclab.ucsf.edu/test.csv | grep MYC curl -L asclab.ucsf.edu/test.csv | grep -w MYC curl -L asclab.ucsf.edu/test.csv | grep -w '^MYC' curl -L --silent asclab.ucsf.edu/test.csv | grep -w '^MYC' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'ABL' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'ABL1' curl -L --silent asclab.ucsf.edu/test.csv | grep -w 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wI 'ABL1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wI 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wi 'abl1' curl -L --silent asclab.ucsf.edu/test.csv | grep -wi 'abl1' | less -S ssh asclab-c1.ucsf.edu","title":"Miscellaneous commands"},{"location":"clusters/","text":"Clusters Still working on this\u2026","title":"Cluster jobs"},{"location":"clusters/#clusters","text":"Still working on this\u2026","title":"Clusters"},{"location":"cmd/02-Data_Processing/","text":"ls -l ls .. pwd ls -las | less mkdir tutorial cd tutorial/ ls -las touch filename ls -las cat filename echo \"\" > filename ls -la cat filename rm filename ls -l touch filename mkdir sub-directory rmdir sub-directory/ mkdir sub-directory ls -l touch sub-directory/newfile rmdir sub-directory/ rm sub-directory/newfile rmdir sub-directory/ mkdir sub-directory touch sub-directory/newfile touch sub-directory/newfile2 touch sub-directory/newfile3 touch sub-directory/newfile4 ls -l sub-directory/ rm -r sub-directory/ ls -l rm -r ls -l mv filename new-filename ls -l mkdir sub-directory mv new-filename sub-directory/ ls -l ls -l sub-directory/ mv sub-directory/new-filename back_here ls -l ls -lR touch sub-directory/testing2 ls -lR find . find sub-directory/ find . -name 'test' find . -name '*test*' find . -name 'test*' find . -name 't*' find . -name '*2' clear ls -l back_here history module avail module add tabutils tabutils module cd /asclab/projects/spcg/ ls -l cd reports/ ls -l cd snvs/ ls -l ls -lh cd /asclab/projects/spcg/reports/snvs/ ls -lh tabutils cat SPCG-UCPG.mutect.filtered.annotated.txt.gz | less tabutils less SPCG-UCPG.mutect.filtered.annotated.txt.gz ps ps eax ps eaxu ps eaxu | cs ps eaxu | grep cs tabutils less SPCG-UCPG.mutect.filtered.annotated.txt.gz gunzip gunzip -help gunzip -c SPCG-UCPG.mutect.filtered.annotated.txt.gz | grep -v '^#' | less gunzip -c SPCG-UCPG.mutect.filtered.annotated.txt.gz | grep -v '^#' | less -S gunzip -c SPCG-UCPG.mutect.filtered.annotated.txt.gz | grep -v '^#' | tabutils less gunzip -c SPCG-UCPG.mutect.filtered.annotated.txt.gz | grep -v '^#' | grep 'OS | tabutils less cd /asclab/projects/spcg/subjects/*186 ls -l cd SPCG-OS186_6G_14M pwd cd /asclab/projects/spcg/subjects/*186/*G_14M ls -l ps -eax ps -eaxu | cs ps -eaxu | grep cs pwd cd /asclab/projects/spcg/subjects/*186/*G_14M ls -l ls -l /asclab/projects/spcg/subjects/ ls -l /asclab/projects/spcg/subjects/ | less ls -l pwd ls -l ls ls -l cd variants ls -l pwd tabutils less *txt.gz ls *txt.gz cat SPCG-OS186_6G_14M.mutect.filtered.tstv.txt cat *tstv.txt less SPCG-OS186_6G_14M.mutect.filtered.annotated.bed tabutils less SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | wc gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | wc -l gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | grep 'EXON' | tabutils less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | grep 'EXON' | wc -l gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | grep 'EXON' | grep 'HIGH' | tabutils less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | grep 'EXON' | grep 'CANCER' | tabutils less tabutils less SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | less -S cat *tstv.txt grep Ts *tstv.txt grep EXON *txt.gz gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | tabutils less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | awk '{print $1}' | less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | awk '{print $1}' | uniq gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep -v '^#' | awk '{print $1}' | uniq -c gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep 'TP53' | less gunzip -c SPCG-OS186_6G_14M.mutect.filtered.annotated.txt.gz | grep 'TP53' | tabutils less","title":"Data pipelines"},{"location":"cmd/common/","text":"Common commands The command-line consists of a command-prompt and then output from the command. These are some of the more common commands you\u2019ll use when trying to navigate and work with a Unix/Linux server. Before you use these though, you should make sure that you understand some of these Unix concepts . Note Below, when you see a $ , this is a command-prompt. This is where you\u2019d type an instruction on the command line for the computer to do. This is a simple prompt and yours will probably look a little more complicated. In fact, it may look more like this: username@server:~$ The only difference between the two forms is that the later includes a little more information (and how to change yours is covered in the customization section). The key thing to know is that anything after the $ is where you type. In order to execute the command, hit the return \u21b5 or enter \u21b5 key. Tips and tricks History When you are typing commands, you will often want to repeat or edit an earlier command. In most shells, you can browse your earlier commands by using your up \u2191 and down \u2193 arrow keys. You can then move the cursor left and right to edit your command as necessary. Note Your entire command history is stored for you in either $HOME/.bash_history or $HOME/.zsh_history , depending on the shell you are using (see customizing for more information). Tab completion There are many times when you want to do something to a specific file, but don\u2019t want to type a full name. In this case, you can often use tab \u21e5 completion. If you type the first few letters of a file, you can hit the tab \u21e5 key and the shell will finish the rest of the name or command for you. If there is any ambiguity in a name, the shell will complete as much of the name for you as it can. This is a handy shortcut that can save you a lot of typing. File globs Another way to save some time is to use a file glob instead of typing a full filename. For example, if you have a bunch of text files (all ending in .txt ) that you wanted to copy to a new directory ( dest ), you could type all of the file names one-by-one, or you could use a file glob. A glob is a wildcard character that allow for quick pattern matching when entering filenames. So, in the above example, instead of typing this following: $ cp a.txt b.txt c.txt d.txt ... dest/ You could type this: $ cp *.txt dest/ There are two globs you can use: * means zero or more of any character. This can be a bit deceiving, because it will also match \u201czero\u201d wildcard characters. So be careful! ? means one (and only one) wildcard character. Danger Typos with file globs can lead to deletion of all of your files if you aren\u2019t careful! There is a big difference between rm *txt and rm * txt . The first deletes all text files. The second deletes all files and the file named txt . So, be careful with spaces! Navigating the file system Listing files in the current directory is performed using the ls command. ls has many options. By default, the sort order of the files is alphabetical, with capital letters first, then lowercase letters (A-Za-z). A few of the more common arguments are listed below. Listing files Listing files in the current directory $ ls file1 file2 file3 file4 Listing the long version\u2026 ls -l $ ls -l -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 What does all of this mean? Let\u2019s look at each column\u2026 Permissions This is probably the most foreign of the fields above. The first character shows if the file is a file or a directory. If this is a directory (see below for an example), then this character will be a d . Otherwise, it is a hyphen - . Next, the fields shows the access level that that each user on the system has to this file. There are 3 main types of permissions: r - read (can the user read the file?) w - write (can the user write to the file?) x - execute (can the user run this as a program?) These values are shown in three sets of triplets. The first triplet shows the user ( u ) permissions. This shows the permissions for the owner . The next is the group ( g ) permissions. Finally the permissions for all other users ( o ). We\u2019ll cover how to set and change these permissions further down, but for now, you just need to know that this is what the rwx stand for. Links This is the number of references to this file in the filesystem. This will almost always be 1, and can be safely ignored for now. Owner This is the username for the user who is listed as the owner of this file. By default they are the user that can set the permissions for other users. Group This is the group that is the group owner for a file. Users can belong to more than one group, which makes this a good mechanism for sharing data with others. Size Modified date Filename Listing all files (including hidden files). Any file that starts with a '.' will be hidden by default. Many programs will write to files that start with a '.' to save configuration or temporary data. All directories contain two directories by default '.' and '..' . '.' is the same as the current directory. So, in the below case file1 and ./file1 point to the exact same file. '..' is the same as the parent directory (up the file hierarchy). '.' and '..' are also considered hidden files. $ ls -la drwxr-xr-x 6 mbreese staff 192 Mar 31 16 :31 . drwxr-xr-x 38 mbreese staff 1216 Mar 31 16 :30 .. -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :33 .hidden_file -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 Here are some other ls options: Arg Meaning -a Show all files -l Long display (permissions, owner, group, size, date) -1 show only one file per line (without the \u2018long\u2019 information) -h human readable file sizes (K, M, G) -t sort by time (newest to oldest) -r reverse the sort (z-aZ-A or oldest to newest) -R recursively display files (display this directory, and all sub-directories) Changing directories Changing to a new directory $ cd new_directory Changing to the parent directory (up a level) $ cd .. \u201c .. \u201d is one of those hidden files, but it is present in every directory, and it always means the parent directory Changing to the root directory (this is the highest level) $ cd / Changing to your home directory (any of these work) $ cd $ cd ~ $ cd $HOME Absolute vs relative pathnames Work in progress Working with files and directories Print your current working directory $ pwd /home/username Directories Creating a directory $ mkdir new_directory Removing a directory $ rmdir bad_directory Danger You can remove only empty directories this way. If the directory has files in it, you need to remove the files first. Alternatively you can use this command to remove both the files and the directory: $ rm -r bad_directory_with_files But be careful \u2013 one wrong finger and you could delete months worth of work. It\u2019s always better to test things out first, before running rm -r . Files cp src dest mv srv dest rm file Permissions File streams Pipes Process control Miscellaneous commands Change your password $ passwd <Prompt for your current password> <Prompt for your new password> <Repeat new password> Print out the date/time $ date Tue Mar 31 16 :28:20 EDT 2020 Clear the screen $ clear What is your username? (This is more helpful in the context of scripts, but still good to know) $ whoami my_username Write something to the screen $ echo \"Hello\" Hello You can also write variables, like $SHELL $ echo \" $SHELL \" /bin/bash Or put them together into one line\u2026 $ echo \"My shell is: $SHELL \" My shell is /bin/bash Calculate an MD5 hash of a file md5 file.txt Note This is useful when comparing two files to see if something changed or a file you\u2019ve downloaded from a remote server. MD5 is an algorithm that takes in a set of data (bytes) and generates a signature. This signature is a fixed size, but will be very different between two different inputs. The algorithm is designed so that any change in the input (as small as one bit) will result in a large difference in the signature. SHA1 is another algorithm that is commonly used for this purpose. These are a family of algorithms called one-way hashes. You feed data in one way and get a hash signature out the other. However, there no going the other way \u2013 you can\u2019t (easily) feed in a signature and recover what bits were used to generate that signature.","title":"Common commands"},{"location":"cmd/common/#tips-and-tricks","text":"","title":"Tips and tricks"},{"location":"cmd/common/#history","text":"When you are typing commands, you will often want to repeat or edit an earlier command. In most shells, you can browse your earlier commands by using your up \u2191 and down \u2193 arrow keys. You can then move the cursor left and right to edit your command as necessary. Note Your entire command history is stored for you in either $HOME/.bash_history or $HOME/.zsh_history , depending on the shell you are using (see customizing for more information).","title":"History"},{"location":"cmd/common/#tab-completion","text":"There are many times when you want to do something to a specific file, but don\u2019t want to type a full name. In this case, you can often use tab \u21e5 completion. If you type the first few letters of a file, you can hit the tab \u21e5 key and the shell will finish the rest of the name or command for you. If there is any ambiguity in a name, the shell will complete as much of the name for you as it can. This is a handy shortcut that can save you a lot of typing.","title":"Tab completion"},{"location":"cmd/common/#file-globs","text":"Another way to save some time is to use a file glob instead of typing a full filename. For example, if you have a bunch of text files (all ending in .txt ) that you wanted to copy to a new directory ( dest ), you could type all of the file names one-by-one, or you could use a file glob. A glob is a wildcard character that allow for quick pattern matching when entering filenames. So, in the above example, instead of typing this following: $ cp a.txt b.txt c.txt d.txt ... dest/ You could type this: $ cp *.txt dest/ There are two globs you can use: * means zero or more of any character. This can be a bit deceiving, because it will also match \u201czero\u201d wildcard characters. So be careful! ? means one (and only one) wildcard character. Danger Typos with file globs can lead to deletion of all of your files if you aren\u2019t careful! There is a big difference between rm *txt and rm * txt . The first deletes all text files. The second deletes all files and the file named txt . So, be careful with spaces!","title":"File globs"},{"location":"cmd/common/#navigating-the-file-system","text":"Listing files in the current directory is performed using the ls command. ls has many options. By default, the sort order of the files is alphabetical, with capital letters first, then lowercase letters (A-Za-z). A few of the more common arguments are listed below.","title":"Navigating the file system"},{"location":"cmd/common/#listing-files","text":"Listing files in the current directory $ ls file1 file2 file3 file4 Listing the long version\u2026 ls -l $ ls -l -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 What does all of this mean? Let\u2019s look at each column\u2026 Permissions This is probably the most foreign of the fields above. The first character shows if the file is a file or a directory. If this is a directory (see below for an example), then this character will be a d . Otherwise, it is a hyphen - . Next, the fields shows the access level that that each user on the system has to this file. There are 3 main types of permissions: r - read (can the user read the file?) w - write (can the user write to the file?) x - execute (can the user run this as a program?) These values are shown in three sets of triplets. The first triplet shows the user ( u ) permissions. This shows the permissions for the owner . The next is the group ( g ) permissions. Finally the permissions for all other users ( o ). We\u2019ll cover how to set and change these permissions further down, but for now, you just need to know that this is what the rwx stand for. Links This is the number of references to this file in the filesystem. This will almost always be 1, and can be safely ignored for now. Owner This is the username for the user who is listed as the owner of this file. By default they are the user that can set the permissions for other users. Group This is the group that is the group owner for a file. Users can belong to more than one group, which makes this a good mechanism for sharing data with others. Size Modified date Filename Listing all files (including hidden files). Any file that starts with a '.' will be hidden by default. Many programs will write to files that start with a '.' to save configuration or temporary data. All directories contain two directories by default '.' and '..' . '.' is the same as the current directory. So, in the below case file1 and ./file1 point to the exact same file. '..' is the same as the parent directory (up the file hierarchy). '.' and '..' are also considered hidden files. $ ls -la drwxr-xr-x 6 mbreese staff 192 Mar 31 16 :31 . drwxr-xr-x 38 mbreese staff 1216 Mar 31 16 :30 .. -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :33 .hidden_file -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file1 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file2 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file3 -rw-r--r-- 1 mbreese staff 0 Mar 31 16 :31 file4 Here are some other ls options: Arg Meaning -a Show all files -l Long display (permissions, owner, group, size, date) -1 show only one file per line (without the \u2018long\u2019 information) -h human readable file sizes (K, M, G) -t sort by time (newest to oldest) -r reverse the sort (z-aZ-A or oldest to newest) -R recursively display files (display this directory, and all sub-directories)","title":"Listing files"},{"location":"cmd/common/#changing-directories","text":"Changing to a new directory $ cd new_directory Changing to the parent directory (up a level) $ cd .. \u201c .. \u201d is one of those hidden files, but it is present in every directory, and it always means the parent directory Changing to the root directory (this is the highest level) $ cd / Changing to your home directory (any of these work) $ cd $ cd ~ $ cd $HOME","title":"Changing directories"},{"location":"cmd/common/#absolute-vs-relative-pathnames","text":"Work in progress","title":"Absolute vs relative pathnames"},{"location":"cmd/common/#markdown","text":"Print your current working directory $ pwd /home/username","title":"Files and directories"},{"location":"cmd/common/#directories","text":"Creating a directory $ mkdir new_directory Removing a directory $ rmdir bad_directory Danger You can remove only empty directories this way. If the directory has files in it, you need to remove the files first. Alternatively you can use this command to remove both the files and the directory: $ rm -r bad_directory_with_files But be careful \u2013 one wrong finger and you could delete months worth of work. It\u2019s always better to test things out first, before running rm -r .","title":"Directories"},{"location":"cmd/common/#files","text":"cp src dest mv srv dest rm file","title":"Files"},{"location":"cmd/common/#permissions","text":"","title":"Permissions"},{"location":"cmd/common/#file-streams","text":"","title":"File streams"},{"location":"cmd/common/#pipes","text":"","title":"Pipes"},{"location":"cmd/common/#process-control","text":"","title":"Process control"},{"location":"cmd/common/#miscellaneous-commands","text":"Change your password $ passwd <Prompt for your current password> <Prompt for your new password> <Repeat new password> Print out the date/time $ date Tue Mar 31 16 :28:20 EDT 2020 Clear the screen $ clear What is your username? (This is more helpful in the context of scripts, but still good to know) $ whoami my_username Write something to the screen $ echo \"Hello\" Hello You can also write variables, like $SHELL $ echo \" $SHELL \" /bin/bash Or put them together into one line\u2026 $ echo \"My shell is: $SHELL \" My shell is /bin/bash Calculate an MD5 hash of a file md5 file.txt Note This is useful when comparing two files to see if something changed or a file you\u2019ve downloaded from a remote server. MD5 is an algorithm that takes in a set of data (bytes) and generates a signature. This signature is a fixed size, but will be very different between two different inputs. The algorithm is designed so that any change in the input (as small as one bit) will result in a large difference in the signature. SHA1 is another algorithm that is commonly used for this purpose. These are a family of algorithms called one-way hashes. You feed data in one way and get a hash signature out the other. However, there no going the other way \u2013 you can\u2019t (easily) feed in a signature and recover what bits were used to generate that signature.","title":"Miscellaneous commands"},{"location":"cmd/concepts/","text":"Concepts Linux and Unix in general is built upon a few key concepts. Knowing these concepts will help you understand what programs are available to you, and when each of them is appropriate. The \u201cdesign\u201d of most Linux systems is consistent with these concepts, regardless of which specific flavor (or distribution) or Linux you are using. These concepts are also applicable to other operating systems (Mac and Windows), to some extent. Users and groups File system !!! note Bits and bytes and kilobytes, etc.. Shell The shell is the program that you are interacting with on the command-line. It is responsible for reading your commands and then figuring out how to execute them. For more information about shells and how to change them to suit your needs, check out customizing your shell . Scripts Input/Output streams Processes Return codes","title":"Unix concepts"},{"location":"cmd/concepts/#concepts","text":"Linux and Unix in general is built upon a few key concepts. Knowing these concepts will help you understand what programs are available to you, and when each of them is appropriate. The \u201cdesign\u201d of most Linux systems is consistent with these concepts, regardless of which specific flavor (or distribution) or Linux you are using. These concepts are also applicable to other operating systems (Mac and Windows), to some extent.","title":"Concepts"},{"location":"cmd/concepts/#users-and-groups","text":"","title":"Users and groups"},{"location":"cmd/concepts/#file-system","text":"!!! note Bits and bytes and kilobytes, etc..","title":"File system"},{"location":"cmd/concepts/#shell","text":"The shell is the program that you are interacting with on the command-line. It is responsible for reading your commands and then figuring out how to execute them. For more information about shells and how to change them to suit your needs, check out customizing your shell .","title":"Shell"},{"location":"cmd/concepts/#scripts","text":"","title":"Scripts"},{"location":"cmd/concepts/#inputoutput-streams","text":"","title":"Input/Output streams"},{"location":"cmd/concepts/#processes","text":"","title":"Processes"},{"location":"cmd/concepts/#return-codes","text":"","title":"Return codes"},{"location":"cmd/customizing/","text":"Customizing your shell The shell is just another program that runs to manage your command-line access. In fact, the command prompt you use is basicall treated like a shell script where each line executed as it is being written. Because of this, it is highly customizable. If you\u2019re using the bash shell (and this is the default on many systems), then you can edit the file $HOME/.bashrc to customize your shell. Another common shell is zsh (the new default on macOS). If you are using this shell, then you can edit the file $HOME/.zshrc . Note There are a few zsh special functions, but zsh can be considered a close relative of bash. Most (all?) of the commands from bash will work in zsh (but not vice-versa). How do you find out which one you\u2019re using? There are a few methods, but the easiest is to run this snippet: $ echo $SHELL It will print out the exact program that you are currently using for your shell. So long as you are using either bash or zsh, this page will work for you. If you have a different shell (csh, tcsh, etc), then you\u2019re on your own. \ud83d\ude00 .bashrc This is a tiny bit of bash code that gets run whenever you start a new session, whether that be because you login to the system (for remote access) or if you open a new Terminal window on your local machine. It is common to put any changes to the default bash environment in this file. Note There are a few configuration files available to users to adjust the bash environment. These are all included at different times, so it can be a bit confusing as to which file to edit. However, $HOME/.bashrc is almost always the included, so if you start here, it will almost always work! Path The $PATH setting determines where bash will look for programs. For example, most of the command-line programs the OS provides are located in either /bin or /usr/bin . So, if you want to run the date program, bash will check each directory in your $PATH to see if it contains an executable program called date . This is the most common setting you\u2019ll want to adjust to customize your shell. $PATH is a colon ( : ) delimited variable that contains a list of these directories to check. For example, here is a common $PATH : PATH=/bin:/usr/bin:$HOME/local/bin You can see your path if you print this variable: $ echo $PATH If you want to add a directory to your $PATH , you can add this line to your $HOME/.bashrc file: export PATH=$PATH:/new/dir What this does is set the variable $PATH equal to $PATH:/new/dir , which is to say, the old $PATH plus the directory /new/dir . The command export tells bash that this variable should be included in the environment, instead of a variable that is local to only the script being executed. For the purposes of setting the $PATH variable, you almost always want to export it as opposed to just setting it. Aliases Prompt","title":"Customizing the shell"},{"location":"cmd/customizing/#customizing-your-shell","text":"The shell is just another program that runs to manage your command-line access. In fact, the command prompt you use is basicall treated like a shell script where each line executed as it is being written. Because of this, it is highly customizable. If you\u2019re using the bash shell (and this is the default on many systems), then you can edit the file $HOME/.bashrc to customize your shell. Another common shell is zsh (the new default on macOS). If you are using this shell, then you can edit the file $HOME/.zshrc . Note There are a few zsh special functions, but zsh can be considered a close relative of bash. Most (all?) of the commands from bash will work in zsh (but not vice-versa).","title":"Customizing your shell"},{"location":"cmd/customizing/#bashrc","text":"This is a tiny bit of bash code that gets run whenever you start a new session, whether that be because you login to the system (for remote access) or if you open a new Terminal window on your local machine. It is common to put any changes to the default bash environment in this file. Note There are a few configuration files available to users to adjust the bash environment. These are all included at different times, so it can be a bit confusing as to which file to edit. However, $HOME/.bashrc is almost always the included, so if you start here, it will almost always work!","title":".bashrc"},{"location":"cmd/customizing/#path","text":"The $PATH setting determines where bash will look for programs. For example, most of the command-line programs the OS provides are located in either /bin or /usr/bin . So, if you want to run the date program, bash will check each directory in your $PATH to see if it contains an executable program called date . This is the most common setting you\u2019ll want to adjust to customize your shell. $PATH is a colon ( : ) delimited variable that contains a list of these directories to check. For example, here is a common $PATH : PATH=/bin:/usr/bin:$HOME/local/bin You can see your path if you print this variable: $ echo $PATH If you want to add a directory to your $PATH , you can add this line to your $HOME/.bashrc file: export PATH=$PATH:/new/dir What this does is set the variable $PATH equal to $PATH:/new/dir , which is to say, the old $PATH plus the directory /new/dir . The command export tells bash that this variable should be included in the environment, instead of a variable that is local to only the script being executed. For the purposes of setting the $PATH variable, you almost always want to export it as opposed to just setting it.","title":"Path"},{"location":"cmd/customizing/#aliases","text":"","title":"Aliases"},{"location":"cmd/customizing/#prompt","text":"","title":"Prompt"},{"location":"cmd/otherlinks/","text":"Other links Here are some other sites that might be useful to people looking to learn more about working with the command-line. http://mally.stanford.edu/~sr/computing/basic-unix.html","title":"Links"},{"location":"cmd/otherlinks/#other-links","text":"Here are some other sites that might be useful to people looking to learn more about working with the command-line. http://mally.stanford.edu/~sr/computing/basic-unix.html","title":"Other links"},{"location":"cmd/scripts/","text":"Writing shell scripts Work in progress","title":"Writing scripts"},{"location":"cmd/scripts/#writing-shell-scripts","text":"Work in progress","title":"Writing shell scripts"},{"location":"cmd/terminal/","text":"The terminal The terminal is the common interface for all command-line access. Most often, the terminal will be a GUI program that just has a big, blank text area with a command-prompt. A GUI isn\u2019t required, however\u2026 terminals can be seen when a computer starts in text-mode, or even accessed through a web-site. Opening a terminal Mac To open a terminal session on a Mac, you will need to run the Terminal application. It is located in /Applications/Utilities/Terminal.app Note One easy way to do this is to use Spotlight Search ( \u2318-space ) and type Terminal to quickly start the program. Disconnecting When you are done with your session and want to cleanly exit, run the exit command. This will close this terminal session. The window may still appear, but it can be safely closed. Alternatively, you could also quit the program entirely with \u2318-q . This will only work if there aren\u2019t other programs still running. Windows Windows, doesn\u2019t have a good default terminal available. Because of this, you will need to skip ahead to the Remote server (SSH) section. Note There are terminal programs for Windows, including Cygwin and the WSL; however setting these up is outside of the scope of this tutorial. When getting started, it is easier to SSH to a server and get started there. Remote server (via SSH) Connecting to a remote server has many advantages over using only your local computer. First, the amount of processing power and storage on remote server can be significantly greater than that of a laptop. Second, when you are using a shared server, it is easier to share data and programs with others. The main network protocol that is used to connect to a remote server is called SSH. This stands for \u201cSecure Shell\u201d. This program works by creating an encrypted tunnel between your computer and the remote server. When you are using SSH, you are connecting to the remote server in as secure a manner as possible. Note When you connect to a remote server, your local computer (laptop / desktop / phone), is also known as the \u201cclient\u201d. So, if you see the word \u201cclient\u201d, that almost always refers to the local computer you are physically using. The \u201cserver\u201d is almost always the remote computer you are connected to. Connecting to the remote server Mac / Linux When using a Mac or Linux computer, SSH is built into the operating system. However, it is not a graphical (GUI) program, but rather a command-line program. In order to start SSH, you need to first open a terminal ( see above ). Next, the command you need to enter is: $ ssh username@hostname Where the username is your username on the remote server and hostname is the hostname or ip-address of the server. For example, to connect to the remote server example.com with the username of billy , you\u2019d type: $ ssh billy@example.com If this looks a bit like an email address, that\u2019s because they both refer to similar concepts \u2014 a user account on a specific server! And if your username on the remote server is the same as your username on your desktop/laptop, you don\u2019t even need to tell SSH the password. The SSH program is quite powerful, and can be used to do many other things, such as creating tunnels to remote servers, but for now, we\u2019ll just concentrate on the primary purpose of connecting to remote servers. Windows Using SSH on a Windows computer requires a GUI client 1 . Putty One SSH client that I\u2019ve used in the past is: PuTTY . This is one of the most commonly used Windows SSH clients, and will support any of the commands that we will discuss in this tutorial. https://www.chiark.greenend.org.uk/~sgtatham/putty/ MobaXterm Another recommended option is MobaXterm, which is a more full-featured program that includes support for tabbed connections and X11 graphics. https://mobaxterm.mobatek.net/ Security Regardless of the method you use to connect to a remote server, when you connect the first time to a server, the SSH software will likely ask you to confirm the server\u2019s identity. This is a normal prompt the first time you connect to a server. You will be presented with a signature (SHA256, MD5, etc) of the key that will look something like this: ECDSA key fingerprint is SHA256:zC45ZzJRNzPYcjdS7dTHULo16Zl71g7sgm2fwC0ShGA . These signatures are a security feature used to confirm that you\u2019re connecting to the server you expect and that no one else is listening into your connection. But, the first time you connect to a server, you may not know this information. If the remote server\u2019s administrator has given you these signatures, then you can compare that values you have to the ones you expect. But, if you don\u2019t have the signatures beforehand, you\u2019ll probably have to trust that the server is who they say they are. The entire point of SSH is security (SSH stands for \u201csecure shell\u201d), so if you have any questions, you should ask the server\u2019s admin. Disconnecting When you are done with your session and want to cleanly exit, again you can run the exit command. This will close the connection to the remote server. This will only work if there aren\u2019t background jobs running on the server. If you get a message about \u201csuspended jobs\u201d, check the section on process control . Authentication In general, most servers allow you to authenticate with a username/password combination. However, it can get tiring typing passwords all the time \u2014 also, using passwords isn\u2019t as secure as possible. Because of this, some servers require the use of public/private keys. Public key encryption is out of the scope for this tutorial, but if you\u2019re interested in learning more, you can check out the Wikipedia entry on Public key cryptography . The basic concept though is that you have two keys: the public one and the private one. The public one is what you can hand out to other people\u2026 in this case the other server. The private key, you keep secret. It should always stay on your computer and never be copied to the server. The server also has a set of public/private keys. When you talk to the server, you use your private key and its public key. When the server sends information to you, it uses its private key and your public key. Mac / Linux For the purposes of SSH, if you need to generate a public key to use to connect to a server, there is a program called ssh-keygen that will handle it for you. When you run this program, it will generate a fresh public/private key pair for you. You can set a password on the key, which will let you access the key. It is highly recommended that you set a password for the key. By default, this key will be named $HOME/.ssh/id_rsa or $HOME/.ssh/id_dsa , depending on the configured algorithm. Don\u2019t worry, the server will likley be able to handle either format. Note Wait\u2026 but I thought that using a password wasn\u2019t as secure as public keys?!? If that\u2019s the case, then why another password? Originally, the password was send to the remote server to authenticate you. With public/private keys, it is your key that authenticates you. The password protects your private key on your computer\u2026 the password and private key never get sent anywhere. The key is what authenticates you with the server. The password for the key is used to \u201cunlock\u201d the key so that it can be used to authenticate you with the server. For more information, see this help document from Github: https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent Windows For Windows, the program PuTTYgen can also be used to generate keys. For more information see these links: https://www.ssh.com/ssh/putty/windows/puttygen/ https://www.puttygen.com/ SSH configuration As your SSH settings get more complex, you may want to look at writing an ssh config file. This file contains all of the settings that you\u2019d normally use (like hostname, username, and if you use different keys for different servers). The settings can be set for a per-server or global basis. On Mac/Linux, this file is located in $HOME/.ssh/config . On Windows, the values can all be set in PuTTY. For more information see these sites: https://www.digitalocean.com/community/tutorials/how-to-configure-custom-connection-options-for-your-ssh-client https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file (Windows) https://www.ssh.com/ssh/putty/windows/ SSH alternatives There are a few alternatives for connecting to a remote server. One relatively common alternative is mosh , which stands for \u201cMobile shell\u201d. This program still uses SSH for the initial authentication steps, but after that, the programs are very different. Mosh is designed to be used on mobile phone networks where the connections are not expected to be robust. To account for this, mosh is designed to work around issues like dropped connections and changed IP addresses. Not all servers support mosh, but if you routinely connect to a remote server using a mobile phone network (or even spotty WiFi), it can be a great tool. Again, I\u2019m intentionally ignoring things like WSL and Cygwin. \u21a9","title":"Terminal / SSH"},{"location":"cmd/terminal/#opening-a-terminal","text":"","title":"Opening a terminal"},{"location":"cmd/terminal/#mac","text":"To open a terminal session on a Mac, you will need to run the Terminal application. It is located in /Applications/Utilities/Terminal.app Note One easy way to do this is to use Spotlight Search ( \u2318-space ) and type Terminal to quickly start the program.","title":"Mac"},{"location":"cmd/terminal/#windows","text":"Windows, doesn\u2019t have a good default terminal available. Because of this, you will need to skip ahead to the Remote server (SSH) section. Note There are terminal programs for Windows, including Cygwin and the WSL; however setting these up is outside of the scope of this tutorial. When getting started, it is easier to SSH to a server and get started there.","title":"Windows"},{"location":"cmd/terminal/#remote-server-via-ssh","text":"Connecting to a remote server has many advantages over using only your local computer. First, the amount of processing power and storage on remote server can be significantly greater than that of a laptop. Second, when you are using a shared server, it is easier to share data and programs with others. The main network protocol that is used to connect to a remote server is called SSH. This stands for \u201cSecure Shell\u201d. This program works by creating an encrypted tunnel between your computer and the remote server. When you are using SSH, you are connecting to the remote server in as secure a manner as possible. Note When you connect to a remote server, your local computer (laptop / desktop / phone), is also known as the \u201cclient\u201d. So, if you see the word \u201cclient\u201d, that almost always refers to the local computer you are physically using. The \u201cserver\u201d is almost always the remote computer you are connected to.","title":"Remote server (via SSH)"},{"location":"cmd/terminal/#connecting-to-the-remote-server","text":"","title":"Connecting to the remote server"},{"location":"cmd/terminal/#mac-linux","text":"When using a Mac or Linux computer, SSH is built into the operating system. However, it is not a graphical (GUI) program, but rather a command-line program. In order to start SSH, you need to first open a terminal ( see above ). Next, the command you need to enter is: $ ssh username@hostname Where the username is your username on the remote server and hostname is the hostname or ip-address of the server. For example, to connect to the remote server example.com with the username of billy , you\u2019d type: $ ssh billy@example.com If this looks a bit like an email address, that\u2019s because they both refer to similar concepts \u2014 a user account on a specific server! And if your username on the remote server is the same as your username on your desktop/laptop, you don\u2019t even need to tell SSH the password. The SSH program is quite powerful, and can be used to do many other things, such as creating tunnels to remote servers, but for now, we\u2019ll just concentrate on the primary purpose of connecting to remote servers.","title":"Mac / Linux"},{"location":"cmd/terminal/#windows_1","text":"Using SSH on a Windows computer requires a GUI client 1 .","title":"Windows"},{"location":"cmd/terminal/#security","text":"Regardless of the method you use to connect to a remote server, when you connect the first time to a server, the SSH software will likely ask you to confirm the server\u2019s identity. This is a normal prompt the first time you connect to a server. You will be presented with a signature (SHA256, MD5, etc) of the key that will look something like this: ECDSA key fingerprint is SHA256:zC45ZzJRNzPYcjdS7dTHULo16Zl71g7sgm2fwC0ShGA . These signatures are a security feature used to confirm that you\u2019re connecting to the server you expect and that no one else is listening into your connection. But, the first time you connect to a server, you may not know this information. If the remote server\u2019s administrator has given you these signatures, then you can compare that values you have to the ones you expect. But, if you don\u2019t have the signatures beforehand, you\u2019ll probably have to trust that the server is who they say they are. The entire point of SSH is security (SSH stands for \u201csecure shell\u201d), so if you have any questions, you should ask the server\u2019s admin.","title":"Security"},{"location":"cmd/terminal/#disconnecting","text":"When you are done with your session and want to cleanly exit, again you can run the exit command. This will close the connection to the remote server. This will only work if there aren\u2019t background jobs running on the server. If you get a message about \u201csuspended jobs\u201d, check the section on process control .","title":"Disconnecting"},{"location":"cmd/terminal/#authentication","text":"In general, most servers allow you to authenticate with a username/password combination. However, it can get tiring typing passwords all the time \u2014 also, using passwords isn\u2019t as secure as possible. Because of this, some servers require the use of public/private keys. Public key encryption is out of the scope for this tutorial, but if you\u2019re interested in learning more, you can check out the Wikipedia entry on Public key cryptography . The basic concept though is that you have two keys: the public one and the private one. The public one is what you can hand out to other people\u2026 in this case the other server. The private key, you keep secret. It should always stay on your computer and never be copied to the server. The server also has a set of public/private keys. When you talk to the server, you use your private key and its public key. When the server sends information to you, it uses its private key and your public key.","title":"Authentication"},{"location":"cmd/terminal/#mac-linux_1","text":"For the purposes of SSH, if you need to generate a public key to use to connect to a server, there is a program called ssh-keygen that will handle it for you. When you run this program, it will generate a fresh public/private key pair for you. You can set a password on the key, which will let you access the key. It is highly recommended that you set a password for the key. By default, this key will be named $HOME/.ssh/id_rsa or $HOME/.ssh/id_dsa , depending on the configured algorithm. Don\u2019t worry, the server will likley be able to handle either format. Note Wait\u2026 but I thought that using a password wasn\u2019t as secure as public keys?!? If that\u2019s the case, then why another password? Originally, the password was send to the remote server to authenticate you. With public/private keys, it is your key that authenticates you. The password protects your private key on your computer\u2026 the password and private key never get sent anywhere. The key is what authenticates you with the server. The password for the key is used to \u201cunlock\u201d the key so that it can be used to authenticate you with the server. For more information, see this help document from Github: https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent","title":"Mac / Linux"},{"location":"cmd/terminal/#windows_2","text":"For Windows, the program PuTTYgen can also be used to generate keys. For more information see these links: https://www.ssh.com/ssh/putty/windows/puttygen/ https://www.puttygen.com/","title":"Windows"},{"location":"cmd/terminal/#ssh-configuration","text":"As your SSH settings get more complex, you may want to look at writing an ssh config file. This file contains all of the settings that you\u2019d normally use (like hostname, username, and if you use different keys for different servers). The settings can be set for a per-server or global basis. On Mac/Linux, this file is located in $HOME/.ssh/config . On Windows, the values can all be set in PuTTY. For more information see these sites: https://www.digitalocean.com/community/tutorials/how-to-configure-custom-connection-options-for-your-ssh-client https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file (Windows) https://www.ssh.com/ssh/putty/windows/","title":"SSH configuration"},{"location":"cmd/terminal/#ssh-alternatives","text":"There are a few alternatives for connecting to a remote server. One relatively common alternative is mosh , which stands for \u201cMobile shell\u201d. This program still uses SSH for the initial authentication steps, but after that, the programs are very different. Mosh is designed to be used on mobile phone networks where the connections are not expected to be robust. To account for this, mosh is designed to work around issues like dropped connections and changed IP addresses. Not all servers support mosh, but if you routinely connect to a remote server using a mobile phone network (or even spotty WiFi), it can be a great tool. Again, I\u2019m intentionally ignoring things like WSL and Cygwin. \u21a9","title":"SSH alternatives"},{"location":"cmd/transfer/","text":"Transferring data Getting data onto a remote system and getting results back to your local computer can sometimes be a bit of a challenge. Unsurprisingly, there are a few options available to you, including some good GUI options. Command-line programs For the below programs, scp and sftp should be already installed. If you are using Windows, there are command-line versions of these programs available as well, such as those supplied with PuTTY (although, they may have slightly different names). rsync is also installed by default on Macs, but you may need to install it separately if you are using a Linux client. scp , sftp , and rsync all work over the SSH protocol, so for any server that you can connect to via SSH, you can use these programs to transfer data. scp scp can be used to copy files from one location to another. The locations can be local or remote. You can even use scp to transfer files from one server to a different server. scp localfile username @server : dest_dir / filename scp username @server : dest_dir / filename local_dir / local_file sftp sftp is like scp , but interactive. You can connect to the remote SFTP server, list files, get files, put files, etc\u2026 This is a command-line program, but it is one way to interactively browse around the files on a remote server. sftp username@server Once connected, you can ls and cd to navigate around. When you want to download a file, run get remote_filename . When you want to upload a file, run put local_filename When you are done and want to disconnect, run exit . rsync A final option is rsync . Rsync works by finding the files changed between two locations (local and remote), and sending only the changed data between the two. This is particularly helpful when you are transfering a lot of data or trying to keep two computers in sync with each other. This can also be used to copy files on the same server or between servers. rsync localfile username @server : dest_dir / filename rsync username @server : dest_dir / filename local_dir / local_file rsync localfile1 localfile2 rsync username @server1 : dir / filename username @server2 : dest_dir / filename If this looks the same as the scp instructions, that\u2019s because it is! However, you almost always want to run rsync with a few options. rsync - avz --progress localfile username@server:dest_dir/filename rsync - avz --progress username@server:dest_dir/filename local_dir/local_file rsync - av --progress localfile1 localfile2 rsync - avz --progress username@server1:dir/filename username@server2:dest_dir/filename Here, we added the -a , -v , -z and --progress options. -a stands for \u201carchive\u201d, which sync directories (recursively), permissions, dates, owner information, etc. Not all of these will translate to your local computer, but it is very useful when transferring files on the same server or between servers with the same user/group configurations. -v stands for \u201cverbose\u201d. This will print out a bit more information about the transfer on the terminal for you to see how the transfer is progressing. -z enables zlib compression while you are transferring. This doesn\u2019t help if you are copying files on the same server, but can save a lot of bandwidth when copying to/from a remote server. Finally, the --progress option tells rsync to print out a progress meter for the current transfer. It isn\u2019t necessary, but it is a nice way to monitor the status of the current file\u2019s transmission. Downloading with HTTP/FTP Another option you have to get data onto a server is to download it from a public web (HTTP) or FTP server. There are two primary tools that you can use at the command line to manage this: curl and wget . They are roughly equivalent for this purpose and pretty easy to use. The main benefit of using tools like this is that you have a great deal of visibility into the data transfer if/when things go wrong. For a simple download though, they are pretty easy to use. Below is an example of how to download a file using curl: curl -LO https://example.com/test.dat In this example, the file you want to download is located at this URL: https://example.com/test.dat . The -L in the argument list tells curl to follow any redirection commands the server sends. Sometimes a server will redirect you to a different URL to download data. One common example is a redirection from a non-encrypted connection (HTTP) to an encrypted one (HTTPS). This is very common and happens transparently when you use a GUI web browser like Google Chrome or Firefox. Unfortunately, we have to explicitly tell curl to do the same. The -O argument tells curl to save the file as test.dat locally. By default, curl will send the data to stdout . GUI Cyberduck (macOS, Windows) If you prefer a GUI program, one option is the Cyberduck program. It is available for Windows and Mac, and can make it easy to upload and download data from a remote server. It is also available for free, which is another bonus (but there is a donation prompt that appears until you register the program for $10). For more information see here: https://cyberduck.io/ WinSCP (Windows) WinSCP is a popular SFTP client for Windows. It has a pretty standard explorer interface where you can browse both your local computer and the remote server. This lets you copy files back and forth between them very easily. It is free to use. MobaXterm (Windows) If you\u2019re using Windows, the MobaXterm program can be used to provide both SSH access to remote servers as well as SFTP access to transfer files back and forth. Secure ShellFish (iOS) There is also an option for data transfer when using an iPad or iPhone! You can use the program Secure ShellFish to link a remote server (using SSH/SFTP) to the iOS Files.app. Cloud file sync services It is possible to use cloud sync services like Dropbox or Box.net with a Linux server, but it can be very complicated to setup. For some enterprise customers these services will sometimes enable an FTP gateway, which lets users upload and download files using an FTP client. However this is not a common setup and not available to everyone. There are also some command-line tools available that will upload and download files from cloud services. One example is from the Cyberduck group called duck.sh . For more information on this, see the Cyberduck wiki .","title":"Tranferring data"},{"location":"cmd/transfer/#transferring-data","text":"Getting data onto a remote system and getting results back to your local computer can sometimes be a bit of a challenge. Unsurprisingly, there are a few options available to you, including some good GUI options.","title":"Transferring data"},{"location":"cmd/transfer/#command-line-programs","text":"For the below programs, scp and sftp should be already installed. If you are using Windows, there are command-line versions of these programs available as well, such as those supplied with PuTTY (although, they may have slightly different names). rsync is also installed by default on Macs, but you may need to install it separately if you are using a Linux client. scp , sftp , and rsync all work over the SSH protocol, so for any server that you can connect to via SSH, you can use these programs to transfer data.","title":"Command-line programs"},{"location":"cmd/transfer/#scp","text":"scp can be used to copy files from one location to another. The locations can be local or remote. You can even use scp to transfer files from one server to a different server. scp localfile username @server : dest_dir / filename scp username @server : dest_dir / filename local_dir / local_file","title":"scp"},{"location":"cmd/transfer/#sftp","text":"sftp is like scp , but interactive. You can connect to the remote SFTP server, list files, get files, put files, etc\u2026 This is a command-line program, but it is one way to interactively browse around the files on a remote server. sftp username@server Once connected, you can ls and cd to navigate around. When you want to download a file, run get remote_filename . When you want to upload a file, run put local_filename When you are done and want to disconnect, run exit .","title":"sftp"},{"location":"cmd/transfer/#rsync","text":"A final option is rsync . Rsync works by finding the files changed between two locations (local and remote), and sending only the changed data between the two. This is particularly helpful when you are transfering a lot of data or trying to keep two computers in sync with each other. This can also be used to copy files on the same server or between servers. rsync localfile username @server : dest_dir / filename rsync username @server : dest_dir / filename local_dir / local_file rsync localfile1 localfile2 rsync username @server1 : dir / filename username @server2 : dest_dir / filename If this looks the same as the scp instructions, that\u2019s because it is! However, you almost always want to run rsync with a few options. rsync - avz --progress localfile username@server:dest_dir/filename rsync - avz --progress username@server:dest_dir/filename local_dir/local_file rsync - av --progress localfile1 localfile2 rsync - avz --progress username@server1:dir/filename username@server2:dest_dir/filename Here, we added the -a , -v , -z and --progress options. -a stands for \u201carchive\u201d, which sync directories (recursively), permissions, dates, owner information, etc. Not all of these will translate to your local computer, but it is very useful when transferring files on the same server or between servers with the same user/group configurations. -v stands for \u201cverbose\u201d. This will print out a bit more information about the transfer on the terminal for you to see how the transfer is progressing. -z enables zlib compression while you are transferring. This doesn\u2019t help if you are copying files on the same server, but can save a lot of bandwidth when copying to/from a remote server. Finally, the --progress option tells rsync to print out a progress meter for the current transfer. It isn\u2019t necessary, but it is a nice way to monitor the status of the current file\u2019s transmission.","title":"rsync"},{"location":"cmd/transfer/#downloading-with-httpftp","text":"Another option you have to get data onto a server is to download it from a public web (HTTP) or FTP server. There are two primary tools that you can use at the command line to manage this: curl and wget . They are roughly equivalent for this purpose and pretty easy to use. The main benefit of using tools like this is that you have a great deal of visibility into the data transfer if/when things go wrong. For a simple download though, they are pretty easy to use. Below is an example of how to download a file using curl: curl -LO https://example.com/test.dat In this example, the file you want to download is located at this URL: https://example.com/test.dat . The -L in the argument list tells curl to follow any redirection commands the server sends. Sometimes a server will redirect you to a different URL to download data. One common example is a redirection from a non-encrypted connection (HTTP) to an encrypted one (HTTPS). This is very common and happens transparently when you use a GUI web browser like Google Chrome or Firefox. Unfortunately, we have to explicitly tell curl to do the same. The -O argument tells curl to save the file as test.dat locally. By default, curl will send the data to stdout .","title":"Downloading with HTTP/FTP"},{"location":"cmd/transfer/#gui","text":"","title":"GUI"},{"location":"cmd/transfer/#cyberduck-macos-windows","text":"If you prefer a GUI program, one option is the Cyberduck program. It is available for Windows and Mac, and can make it easy to upload and download data from a remote server. It is also available for free, which is another bonus (but there is a donation prompt that appears until you register the program for $10). For more information see here: https://cyberduck.io/","title":"Cyberduck (macOS, Windows)"},{"location":"cmd/transfer/#winscp-windows","text":"WinSCP is a popular SFTP client for Windows. It has a pretty standard explorer interface where you can browse both your local computer and the remote server. This lets you copy files back and forth between them very easily. It is free to use.","title":"WinSCP (Windows)"},{"location":"cmd/transfer/#mobaxterm-windows","text":"If you\u2019re using Windows, the MobaXterm program can be used to provide both SSH access to remote servers as well as SFTP access to transfer files back and forth.","title":"MobaXterm (Windows)"},{"location":"cmd/transfer/#secure-shellfish-ios","text":"There is also an option for data transfer when using an iPad or iPhone! You can use the program Secure ShellFish to link a remote server (using SSH/SFTP) to the iOS Files.app.","title":"Secure ShellFish (iOS)"},{"location":"cmd/transfer/#cloud-file-sync-services","text":"It is possible to use cloud sync services like Dropbox or Box.net with a Linux server, but it can be very complicated to setup. For some enterprise customers these services will sometimes enable an FTP gateway, which lets users upload and download files using an FTP client. However this is not a common setup and not available to everyone. There are also some command-line tools available that will upload and download files from cloud services. One example is from the Cyberduck group called duck.sh . For more information on this, see the Cyberduck wiki .","title":"Cloud file sync services"},{"location":"git/","text":"Git source control Git is a version control program. This means that it is used for keeping track of the changes to different files in a repository. When you use git, you can keep track of changes that you\u2019ve made and roll them back if necessary. However, the real power of git comes into play when you\u2019re working with others. In this mode, you can share code or document cahnges with a collaborator. You can both work on the same project independently and then let git help you manage merging your work together.","title":"Git"},{"location":"git/#git-source-control","text":"Git is a version control program. This means that it is used for keeping track of the changes to different files in a repository. When you use git, you can keep track of changes that you\u2019ve made and roll them back if necessary. However, the real power of git comes into play when you\u2019re working with others. In this mode, you can share code or document cahnges with a collaborator. You can both work on the same project independently and then let git help you manage merging your work together.","title":"Git source control"}]}